/* autogenerated by Processing revision 1292 on 2023-08-03 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Cube extends PApplet {

PMatrix3D MatrixF;
PMatrix3D MatrixB;
PMatrix3D MatrixL;
PMatrix3D MatrixR;
PMatrix3D MatrixU;
PMatrix3D MatrixD;
PMatrix3D Matrixf;
PMatrix3D Matrixb;
PMatrix3D Matrixl;
PMatrix3D Matrixr;
PMatrix3D Matrixu;
PMatrix3D Matrixd;


IntList MoveF;
IntList MoveB;
IntList MoveL;
IntList MoveR;
IntList MoveU;
IntList MoveD;
//PMatrix3D inverseMatrix;
float x = 0;
int a = 76;
boolean F,B,L,R,U,D = false;

PVector[] vectors = new PVector[20];
PVector[] nvectors = new PVector[20];
String[] funcNames = {"ccube1", "ccube2", "ccube3","ccube4", "ccube5", "ccube6","ccube7", "ccube8",
                      "mcube1","mcube2","mcube3","mcube4","mcube5","mcube6","mcube7","mcube8","mcube9",
                      "mcube10","mcube11","mcube12"};

public void setup() {
    /* size commented out by preprocessor */; 
    translate(width/2,height/2);
      
    MatrixF = new PMatrix3D();
    MatrixB = new PMatrix3D();
    MatrixL = new PMatrix3D();
    MatrixR = new PMatrix3D();
    MatrixU = new PMatrix3D();
    MatrixD = new PMatrix3D();    
    MatrixF.rotate(PI/2);
    MatrixB.rotate(PI/2);    
    MatrixL.rotateX(PI/2);    
    MatrixR.rotateX(PI/2);   
    MatrixU.rotateY(PI/2);
    MatrixD.rotateY(PI/2);
 
    vectors[0] = new PVector(-a, -a, a);
    vectors[1] = new PVector(a, -a, a);
    vectors[2] = new PVector(-a, -a, -a);
    vectors[3] = new PVector(a, -a, -a);
    vectors[4] = new PVector(-a, a, a);
    vectors[5] = new PVector(-a, a, -a);
    vectors[6] = new PVector(a, a, -a);
    vectors[7] = new PVector(a, a, a);
    vectors[8] = new PVector(-a, 0, a);
    vectors[9] = new PVector(a, 0, a);
    vectors[10] = new PVector(-a, 0, -a);
    vectors[11] = new PVector(a, 0, -a);
    vectors[12] = new PVector(0, -a, -a);
    vectors[13] = new PVector(0, a, -a);
    vectors[14] = new PVector(0, -a, a);
    vectors[15] = new PVector(0, a, a);
    vectors[16] = new PVector(-a, -a, 0);
    vectors[17] = new PVector(a, -a, 0);
    vectors[18] = new PVector(-a, a, 0);
    vectors[19] = new PVector(a, a, 0);
    
    nvectors[0] = new PVector(-a, -a, a);
    nvectors[1] = new PVector(a, -a, a);
    nvectors[2] = new PVector(-a, -a, -a);
    nvectors[3] = new PVector(a, -a, -a);
    nvectors[4] = new PVector(-a, a, a);
    nvectors[5] = new PVector(-a, a, -a);
    nvectors[6] = new PVector(a, a, -a);
    nvectors[7] = new PVector(a, a, a);
    nvectors[8] = new PVector(-a, 0, a);
    nvectors[9] = new PVector(a, 0, a);
    nvectors[10] = new PVector(-a, 0, -a);
    nvectors[11] = new PVector(a, 0, -a);
    nvectors[12] = new PVector(0, -a, -a);
    nvectors[13] = new PVector(0, a, -a);
    nvectors[14] = new PVector(0, -a, a);
    nvectors[15] = new PVector(0, a, a);
    nvectors[16] = new PVector(-a, -a, 0);
    nvectors[17] = new PVector(a, -a, 0);
    nvectors[18] = new PVector(-a, a, 0);
    nvectors[19] = new PVector(a, a, 0);   
}

  public void draw(){
    translate(width/2,height/2);
    rotateY(-degrees(mouseX)/4000);
    rotateX(-degrees(mouseY)/4000);
    background(155);
    strokeWeight(2);

    if (U){
      if (x <= 90){
        x = x + 3;
        pushMatrix();
        rotateY(radians(x));
      for (int value : MoveU) {
        try {
        this.getClass().getMethod(funcNames[value], PVector.class).invoke(this, vectors[value]);
      } catch (Exception e) {
        e.printStackTrace();
        }
      }
      
        popMatrix();
        ccube5(vectors[4]);       
        ccube6(vectors[5]);      
        ccube7(vectors[6]);       
        ccube8(vectors[7]); 
        mcube1(vectors[8]);
        mcube2(vectors[9]);
        mcube3(vectors[10]);
        mcube4(vectors[11]);
        mcube6(vectors[13]);
        mcube8(vectors[15]);
        mcube11(vectors[18]);
        mcube12(vectors[19]);
        }
      else{
        pushMatrix();
        rotateY(radians(90));       
          for (int value : MoveU) {
            try {
              this.getClass().getMethod(funcNames[value], PVector.class).invoke(this, vectors[value]);
                } catch (Exception e) {
                    e.printStackTrace();
            }
           } 
        popMatrix();
        ccube5(vectors[4]);       
        ccube6(vectors[5]);      
        ccube7(vectors[6]);       
        ccube8(vectors[7]); 
        mcube1(vectors[8]);
        mcube2(vectors[9]);
        mcube3(vectors[10]);
        mcube4(vectors[11]);
        mcube6(vectors[13]);
        mcube8(vectors[15]);
        mcube11(vectors[18]);
        mcube12(vectors[19]); 
        }
    }
    
    else if (B){
        if (x <= 90){
        x = x + 3;
        pushMatrix();
        rotate(radians(x));
      for (int value : MoveB) {
    try {
        this.getClass().getMethod(funcNames[value], PVector.class).invoke(this, vectors[value]);
    } catch (Exception e) {
        e.printStackTrace();
    }
      }
      
        popMatrix();
        ccube1(vectors[0]);       
        ccube2(vectors[1]);
        ccube5(vectors[4]);                    
        ccube8(vectors[7]); 
        mcube1(vectors[8]);
        mcube2(vectors[9]);
        mcube7(vectors[14]);
        mcube8(vectors[15]);
        mcube9(vectors[16]);
        mcube10(vectors[17]);
        mcube11(vectors[18]);
        mcube12(vectors[19]);
        }
        else{
        pushMatrix();
        rotate(radians(90));       
          for (int value : MoveB) {
            try {
              this.getClass().getMethod(funcNames[value], PVector.class).invoke(this, vectors[value]);
                } catch (Exception e) {
                    e.printStackTrace();
            }
           } 
        popMatrix();
        ccube1(vectors[0]);       
        ccube2(vectors[1]);
        ccube5(vectors[4]);                   
        ccube8(vectors[7]); 
        mcube1(vectors[8]);
        mcube2(vectors[9]);
        mcube7(vectors[14]);
        mcube8(vectors[15]);
        mcube9(vectors[16]);
        mcube10(vectors[17]);
        mcube11(vectors[18]);
        mcube12(vectors[19]); 
        }
    }
    
    else{
     
      for (int i = 0; i < funcNames.length; i++) {
    try {
        this.getClass().getMethod(funcNames[i], PVector.class).invoke(this, vectors[i]);
    } catch (Exception e) {
        e.printStackTrace();
    }
      }

      //drawcube();      
    }
  }

        //PVector Nvectors = new PVector();
        //vectors[0].x = MatrixU.m00 * vectors[0].x + MatrixU.m01 * vectors[0].y + MatrixU.m02 * vectors[0].z;
        //vectors[0].y = MatrixU.m10 * vectors[0].x + MatrixU.m11 * vectors[0].y + MatrixU.m12 * vectors[0].z;
        //vectors[0].z = MatrixU.m20 * vectors[0].x + MatrixU.m21 * vectors[0].y + MatrixU.m22 * vectors[0].z;
        //println(vectors[0].x,vectors[0].y,vectors[0].z);
        //println(Nvectors[0].x,Nvectors[0].y,Nvectors[0].z);
//class sscube {

//float a, b, c, d;
//this is an constructur (where an object is born)(its name must matchclass name)
//sscube(a, b, c, d){
//    rect(a, b, c, d); 
//}

public void ccube1(PVector vec){
    pushMatrix();
    translate(0, 0, 76);
    fill(255, 0, 0);
    rect(vec.x,vec.y,50,50);
    popMatrix();
    pushMatrix();
    translate(-76, -76, 76);
    rotateY(PI/2);
    fill(0, 255, 0);
    rect(0,0,50,50);
    popMatrix();
    pushMatrix();
    translate(-76, -76, 76);
    rotateX(3*PI/2);
    fill(0, 0, 255);
    rect(0,0,50,50);
    popMatrix();
}

public void ccube2(PVector vec){
    pushMatrix();
    translate(0, 0, 76);
    //scale(0, 0, 0);
    fill(255, 0, 0);
    rect(vec.x - 50, vec.y , 50, 50);
    popMatrix();
    pushMatrix();
    translate(76, -76, 76);
    rotateY(PI/2);
    fill(255, 255, 255);
    rect(0,0,50,50);
    popMatrix();
    pushMatrix();
    translate(76, -76, 76);
    rotateX(3*PI/2);
    fill(0, 0, 255);
    rect(-50,0,50,50);
    popMatrix();
}

public void ccube3(PVector vec){
    pushMatrix();
    translate(0, 0, -76);
    //scale(0, 0, 0);
    fill(255, 255, 0);
    rect(vec.x, vec.y , 50, 50);
    popMatrix();
    pushMatrix();
    translate(-76, -76, -76);
    rotateY(3*PI/2);
    fill(0, 255, 0);
    rect(0,0,50,50);
    popMatrix();
    pushMatrix();
    translate(-76, -76, -76);
    rotateX(PI/2);
    fill(0, 0, 255);
    rect(0,0,50,50);
    popMatrix();
}

public void ccube4(PVector vec){
    pushMatrix();
    translate(0, 0, -76);
    //scale(0, 0, 0);
    fill(255, 255, 0);
    rect(vec.x - 50, vec.y , 50, 50);
    popMatrix();
    pushMatrix();
    translate(76, -76, -76);
    rotateY(3*PI/2);
    fill(255, 255, 255);
    rect(0 ,0 ,50 ,50);
    popMatrix();
    pushMatrix();
    translate(76, -76, -76);
    rotateX(PI/2);
    fill(0, 0, 255);
    rect(-50,0,50,50);
    popMatrix();
}

public void ccube5(PVector vec){
    pushMatrix();
    translate(0, 0, 76);
    //scale(0, 0, 0);
    fill(255, 0, 0);
    rect(vec.x, vec.y - 50, 50, 50);
    popMatrix();
    pushMatrix();
    translate(-76, 76, 76);
    rotateY(PI/2);
    fill(0, 255, 0);
    rect(0,-50,50,50);
    popMatrix();
    pushMatrix();
    translate(-76, 76, 76);
    rotateX(3*PI/2);
    fill(255, 165, 0);
    rect(0,0,50,50);
    popMatrix();
}

public void ccube6(PVector vec){
    pushMatrix();
    translate(0, 0, -76);
    //scale(0, 0, 0);
    fill(255, 255, 0);
    rect(vec.x, vec.y - 50, 50, 50);
    popMatrix();
    pushMatrix();
    translate(-76, 76, -76);
    rotateY(3*PI/2);
    fill(0, 255, 0);
    rect(0,-50,50,50);
    popMatrix();
    pushMatrix();
    translate(-76, 76, -76);
    rotateX(PI/2);
    fill(255, 165, 0);
    rect(0,0,50,50);
    popMatrix();
}

public void ccube7(PVector vec){
    pushMatrix();
    translate(0, 0, -76);
    //scale(0, 0, 0);
    fill(255, 255, 0);
    rect(vec.x -50, vec.y - 50, 50, 50);
    popMatrix();
    pushMatrix();
    translate(76, 76, -76);
    rotateY(3*PI/2);
    fill(255, 255, 255);
    rect(0,-50,50,50);
    popMatrix();
    pushMatrix();
    translate(76, 76, -76);
    rotateX(PI/2);
    fill(255, 165, 0);
    rect(-50,0,50,50);
    popMatrix();
}

public void ccube8(PVector vec){
    pushMatrix();
    translate(0, 0, 76);
    //scale(0, 0, 0);
    fill(255, 0, 0);
    rect(vec.x -50, vec.y - 50, 50, 50);
    popMatrix();
    pushMatrix();
    translate(76, 76, 76);
    rotateY(PI/2);
    fill(255, 255, 255);
    rect(0,-50,50,50);
    popMatrix();
    pushMatrix();
    translate(76, 76, 76);
    rotateX(3*PI/2);
    fill(255, 165, 0);
    rect(-50,0,50,50);
    popMatrix();
}

public void mcube1(PVector vect){
    pushMatrix();
    translate(0, 0, 76);
    fill(255, 0, 0);
    rect(-76, vect.y - 25, 50, 50);
    popMatrix();
    pushMatrix();
    translate(-76, 0, 76);
    rotateY(PI/2);
    fill(0, 255, 0);
    rect(0, vect.y - 25, 50, 50);
    popMatrix();
}

public void mcube2(PVector vect){
    pushMatrix();
    translate(0, 0, 76);
    fill(255, 0, 0);
    rect(76 - 50, vect.y - 25, 50, 50);
    popMatrix();
    pushMatrix();
    translate(76, 0, 76);
    rotateY(PI/2);
    fill(255, 255, 255);
    rect(0, vect.y - 25, 50, 50);
    popMatrix();
}

public void mcube3(PVector vect){
    pushMatrix();
    translate(0, 0, -76);
    fill(255, 255, 0);
    rect(-76, vect.y - 25, 50, 50);
    popMatrix();
    pushMatrix();
    translate(-76, 0, -76);
    rotateY(3*PI/2);
    fill(0, 255, 0);
    rect(0, vect.y - 25, 50, 50);
    popMatrix();
}

public void mcube4(PVector vect){
    pushMatrix();
    translate(0, 0, -76);
    fill(255, 255, 0);
    rect(76 - 50, vect.y - 25, 50, 50);
    popMatrix();
    pushMatrix();
    translate(76, 0, -76);
    rotateY(3*PI/2);
    fill(255, 255, 255);
    rect(0, vect.y - 25, 50, 50);
    popMatrix();
}

public void mcube5(PVector vect){
    pushMatrix();
    translate(0, 0, -76);
    fill(255, 255, 0);
    rect(vect.x - 25, vect.y, 50, 50);
    popMatrix();
    pushMatrix();
    translate(0, -76, -76);
    rotateX(PI/2);
    fill(0, 0, 255);
    rect(vect.x - 25, 0, 50, 50);
    popMatrix();
}

public void mcube6(PVector vect){
    pushMatrix();
    translate(0, 0, -76);
    fill(255, 255, 0);
    rect(vect.x - 25, vect.y - 50, 50, 50);
    popMatrix();
    pushMatrix();
    translate(0, 76, -76);
    rotateX(PI/2);
    fill(255, 165, 0);
    rect(vect.x - 25, 0, 50, 50);
    popMatrix();
}

public void mcube7(PVector vect){
    pushMatrix();
    translate(0, 0, 76);
    fill(255, 0, 0);
    rect(vect.x - 25, vect.y, 50, 50);
    popMatrix();
    pushMatrix();
    translate(0, -76, 76);
    rotateX(3*PI/2);
    fill(0, 0, 255);
    rect(vect.x - 25, 0, 50, 50);
    popMatrix();
}

public void mcube8(PVector vect){
    pushMatrix();
    translate(0, 0, 76);
    fill(255, 0, 0);
    rect(vect.x - 25, vect.y - 50, 50, 50);
    popMatrix();
    pushMatrix();
    translate(0, 76, 76);
    rotateX(3*PI/2);
    fill(255, 165, 0);
    rect(vect.x - 25, 0, 50, 50);
    popMatrix();
}

public void mcube9(PVector vect){
    pushMatrix();
    translate(-76, -76, 25);
    rotateX(3*PI/2);
    fill(0, 0, 255);
    rect(0, 0, 50, 50);
    popMatrix();
    pushMatrix();
    translate(-76, -76, 25);
    rotateY(PI/2);
    fill(0, 255, 0);
    rect(0, 0, 50, 50);
    popMatrix();
}

public void mcube10(PVector vect){
    pushMatrix();
    translate(76, -76, 25);
    rotateX(PI/2);
    fill(0, 0, 255);
    rect(-50, -50, 50, 50);
    popMatrix();
    pushMatrix();
    translate(76, -76, 25);
    rotateY(PI/2);
    fill(255, 255, 255);
    rect(0, 0, 50, 50);
    popMatrix();
}

public void mcube11(PVector vect){
    pushMatrix();
    translate(-76, 76, 25);
    rotateX(3*PI/2);
    fill(255, 165, 0);
    rect(0, 0, 50, 50);
    popMatrix();
    pushMatrix();
    translate(-76, 76, 25);
    rotateY(PI/2);
    fill(0, 255, 0);
    rect(0, -50, 50, 50);
    popMatrix();
}

public void mcube12(PVector vect){
    pushMatrix();
    translate(76, 76, 25);
    rotateX(PI/2);
    fill(255, 165, 0);
    rect(-50, -50, 50, 50);
    popMatrix();
    pushMatrix();
    translate(76, 76, 25);
    rotateY(PI/2);
    fill(255, 255, 255);
    rect(0, -50, 50, 50);
    popMatrix();
}

//}


public void drawcube() {
        ccube1(vectors[0]);       
        ccube2(vectors[1]);       
        ccube3(vectors[2]);       
        ccube4(vectors[3]); 
        ccube5(vectors[4]);       
        ccube6(vectors[5]);      
        ccube7(vectors[6]);       
        ccube8(vectors[7]); 
        mcube1(vectors[8]);
        mcube2(vectors[9]);
        mcube3(vectors[10]);
        mcube4(vectors[11]);
        mcube5(vectors[12]);
        mcube6(vectors[13]);
        mcube7(vectors[14]);
        mcube8(vectors[15]);
        mcube9(vectors[16]);
        mcube10(vectors[17]);
        mcube11(vectors[18]);
        mcube12(vectors[19]);     
}
public void keyPressed(){
  if (key == 'F'){
    F = true;
    MoveF = new IntList();
    for(int i = 0; i<20; i = i + 1){
      if(nvectors[i].z > 25){
        MatrixF.mult(vectors[i], nvectors[i]);
        MoveF.append(i);
        
        //println(i,nvectors[i].x,nvectors[i].y,nvectors[i].z, vectors[i].x, vectors[i].y, vectors[i].z);
      }
   }
   println(MoveF);
    }    
  else if (
    key == 'B'){
    B = true;
    MoveB = new IntList();
    for(int i = 0; i<20; i = i + 1){
      if(nvectors[i].z < -25){
        MatrixB.mult(vectors[i], nvectors[i]);
        MoveB.append(i);
        
        //println(i,nvectors[i].x,nvectors[i].y,nvectors[i].z, vectors[i].x, vectors[i].y, vectors[i].z);
      }
   }
   println(MoveB);
    }
  else if (key == 'L'){
    L = true;
    MoveL = new IntList();
    for(int i = 0; i<20; i = i + 1){
      if(nvectors[i].x < -25){
        MatrixL.mult(vectors[i], nvectors[i]);
        MoveL.append(i);
        
        //println(i,nvectors[i].x,nvectors[i].y,nvectors[i].z, vectors[i].x, vectors[i].y, vectors[i].z);
      }
   }
   println(MoveL);
    }
  else if (key == 'R'){
    R = true;
    MoveR = new IntList();
    for(int i = 0; i < 20; i = i + 1){
      if(nvectors[i].x > 25){
        MatrixR.mult(vectors[i], nvectors[i]);
        MoveR.append(i);
        
        //println(i,nvectors[i].x,nvectors[i].y,nvectors[i].z, vectors[i].x, vectors[i].y, vectors[i].z);
      }
   }
   println(MoveR);
    }
  else if (key == 'U'){
    U = true;
    MoveU = new IntList();
    for(int i = 0; i < 20; i = i + 1){
      if(nvectors[i].y < -25){
        MatrixU.mult(vectors[i], nvectors[i]);
        MoveU.append(i);  
        //println(i,nvectors[i].x,nvectors[i].y,nvectors[i].z, vectors[i].x, vectors[i].y, vectors[i].z);
        
    }
   }
   println(MoveU);  
    }
  else if(key == 'D'){
    D = true;
    MoveD = new IntList();
    for(int i = 0; i<20; i = i + 1){
      if(nvectors[i].y > 25){
        MatrixD.mult(vectors[i], nvectors[i]);
        MoveD.append(i);        
        //println(i,nvectors[i].x,nvectors[i].y,nvectors[i].z, vectors[i].x, vectors[i].y, vectors[i].z);
      }
   }
   println(MoveD);
    }
}


  public void settings() { size(500, 500, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Cube" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
